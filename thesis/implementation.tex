\chapter{Implementation}\label{ch:implementation}

In this chapter, the focus will be on the implementation choices made for the realization of the Layer 7 switch.
We will analyze the programming language, algorithms, data structures, and libraries used to optimize efficiency, modularity, and interaction with the underlying technologies discussed previously. 

\section{Enviroment setup}
From the beginning, our switch was designed to be placed inside a maritime operational technology system, such as a ship, to monitor its internal network.

Since it was not possible to test the software against a physical infrastructure, the creation of a virtual twin seemed the most reasonable choice. In addition, the first step toward legacy compatibility was the ability to run the software on commodity hardware such as a personal computer, which has very limited resources compared to industrial system components.

\subsection{Linux Network-Namespaces}
Linux network-namespaces are a powerful feature that allows users to create isolated network environments within a single host, making them a valuable option for emulation, testing, and development, as they provide a controlled environment in which network configurations can be set up without affecting the host system or other network environments.
Simulations such as the one we focused have core logic that can span multiple, separate environments, making it necessary to be network namespace, or container, aware. By creating a completely new network stack within a namespace for each system component, the containers can completely isolate their network environments from each other, perfectly simulating an industrial environment where each device is a separate entity with its own life cycle.

Taking advantage of the containerization capabilities of the technology, we automated the creation of a simple but complete OT system with a single Makefile.\\

\begin{lstlisting}[language=make]
CONTAINERS := 1 2 3 4 5 6 7 8

.PHONY: test-container-%
test-container-%:
	$(eval I := $(subst test-container-,,$@))
	sudo ip netns add test$(I)
	sudo ip netns exec test$(I) ip link set dev lo up
	sudo ip netns exec test$(I) ip link add eth0 type veth peer name test$(I)
	sudo ip netns exec test$(I) ip link set dev test$(I) netns 1
	sudo ip netns exec test$(I) ip link set dev eth0 address 54:00:00:00:00:$(I)0
	sudo ip netns exec test$(I) ip addr add 10.42.0.$(I)0/24 dev eth0
	sudo ip netns exec test$(I) ip link set dev eth0 up
	sudo ip netns exec test$(I) ip neigh add 10.42.0.$(I) lladdr 54:00:00:00:00:0$(I) nud permanent dev eth0
	sudo ip link set dev test$(I) up
	sudo ip link set dev test$(I) address 54:00:00:00:00:0$(I)
	sudo ip addr add 10.42.0.$(I)/32 dev test$(I) noprefixroute
	sudo ip route add to 10.42.0.$(I)0/32 dev test$(I) src 10.42.0.$(I)
	sudo ethtool -K test$(I) tx off
	sudo ip netns exec test$(I) ethtool -K eth0 tx off

.PHONY: test-net
test-net: $(foreach container,$(CONTAINERS),test-container-$(container) )
\end{lstlisting}

This file alone is enough to configure a completely reliable simulation of a possible infrastructure we might find on a ship.Eight network namespaces representing different physical components are created, and for each one a virtual Ethernet interface is also set up and paired with the loopback interface of the host machine that was previously brought up. As mentioned earlier, in keeping with namespace theory, each container is considered a separate device with its own MAC address, IP address, and network stack.
To be consistent with packet routing and to have a simulation as close to a real context as possible, transmit checksum offloading has also been disabled to avoid unexpected behavior due to the abstraction layers of network virtualization.

\begin{figure}[H]
	\centering
    \includegraphics[scale=0.4]{thesis/images/network_namespaces.png}
	\caption{Visualization of Linux Network Namespaces}
    \label{fig:network_namespaces}
\end{figure}

The only drawback of using network namespaces could be identified in the use abstraction layers of some kind that may give unrealistic results with slower or faster performance compared to the physical counterpart. But for the sake of research and study on the applicability of new networking strategies to legacy systems, our concerns for this part are mainly focused on the reproducibility of the network topology.

\section{The Rust Programming Language}
Upon delivery of packets to User Space, the developer assumes complete authority and accountability for the subsequent management and security of the data. This entails the obligation to ensure data is managed in a type and memory safe environment, with the preservation of information integrity being of paramount importance to the developer. Additionally, the software developed should be tailored to a performance-critical environment, where speed and efficiency are pivotal factors, as well as providing robust error and exception handling. The programming language selected for the switch development, Rust, is characterized by these features.

% correct
To elaborate on the aforementioned point, it should be noted that while all the features described are available in other programming languages, they are not all present simultaneously as in Rust. In addition, the following key aspects contribute to the selection of Rust as the optimal language for this implementation:

\begin{itemize}
    \item\textbf{Algebraic Type System}, which enables the use of product and sum types that can be mixed with a strong pattern matching paradigm. This combination enables a fast and easy way of destructuring and managing of complex data aggregations, which are frequently encountered in simulations characterized by a high level of structural detail
    \item\textbf{Data Ownership}, a paradigm that constitutes a novel approach to the management of variables, ensuring the precise location and modification of data during the execution of a program. This precludes the potential for ambiguous memory behaviors, thereby enhancing the reliability and predictability of program execution
    \item\textbf{Unsafe block declarations} This feature facilitates raw memory access, reminiscent of other low-level languages such as C, while retaining the safety features inherent to Rust.
    In case of a memory error, the process of identifying the underlying cause is expedited since low-level hardware access is permitted within a controlled environment defined by the developer
\end{itemize}

Leveraging these unique features and the rich type system we were able to simulate the ship components and their life cycle within just one file. \\


\begin{lstlisting}[style=rust]
pub struct ShipComponent<'a> {
    pub name: String,
    pub ifname: String,
    pub mac: String,
    pub ip: String,
    pub ifindex: libc::c_uint,
    pub bpf_manager: BPFRedirectManager,
    pub sock: XDPSocket<'a>,
    pub umem_allocator: UmemAllocator,
    pub poll_fd: libc::pollfd,
    pub sends: Vec<String>,
    pub receives: Vec<String>,
}
\end{lstlisting}

It is noteworthy that each ship component is implemented as a Struct product type, which contains the essential values required for its networking management.
In addition to static data, such as the MAC and IP addresses, which are contained within the struct, there exist variables that oversee the AF\_XDP socket, which is bound to the component's NIC. This approach enables a high degree of flexibility by leveraging the impl pattern, which facilitates the definition of methods tailored to the component's specific functionality. A prime illustration of this methodology is evident in the manner in which each component administers the application of the network policy. \\

\begin{lstlisting}[style=rust]
impl ShipComponent<'_> {
.
.
.
    fn apply_policy(&self, message: String) -> (bool, bool, String) {
        let mut nmea = Nmea::new();
        let message_ok = nmea.parse(message.clone());

        match message_ok {
            Ok(()) => {
                // message is valid nmea
                // now gotta check if the message can be sent by the component
                nmea.show();
                let prefix = format!("${}{}", nmea.str_talker_id(), nmea.str_sentence_type());
                let is_allowed = self
                    .sends
                    .iter()
                    .any(|allowed_message| prefix == *allowed_message);
                (is_allowed, true, prefix)
            }

            Err(_) => (true, false, String::from("NONMEA")),
        }
    }

}
\end{lstlisting}




\section{Project Layout}
\section{Algorithmic choices and Crates}
\section{Implementation's highlights}



