\chapter{Implementation}\label{ch:implementation}

In this chapter, the focus will be on the implementation choices made for the realization of the Layer 7 switch.
We will analyze the programming language, algorithms, data structures, and libraries used to optimize efficiency, modularity, and interaction with the underlying technologies discussed previously. 

\section{Enviroment setup}
From the beginning, our switch was designed to be placed inside a maritime operational technology system, such as a ship, to monitor its internal network.

Since it was not possible to test the software against a physical infrastructure, the creation of a virtual twin seemed the most reasonable choice. In addition, the first step toward legacy compatibility was the ability to run the software on commodity hardware such as a personal computer, which has very limited resources compared to industrial system components.

\subsection{Linux Network-Namespaces}
Linux network-namespaces are a powerful feature that allows users to create isolated network environments within a single host, making them a valuable option for emulation, testing, and development, as they provide a controlled environment in which network configurations can be set up without affecting the host system or other network environments.
Simulations such as the one we focused have core logic that can span multiple, separate environments, making it necessary to be network namespace, or container, aware. By creating a completely new network stack within a namespace for each system component, the containers can completely isolate their network environments from each other, perfectly simulating an industrial environment where each device is a separate entity with its own life cycle.

Taking advantage of the containerization capabilities of the technology, we automated the creation of a simple but complete OT system with a single Makefile.\\

\leavevmode\newline

\begin{lstlisting}[language=make]
CONTAINERS := 1 2 3 4 5 6 7 8

.PHONY: test-container-%
test-container-%:
	$(eval I := $(subst test-container-,,$@))
	sudo ip netns add test$(I)
	sudo ip netns exec test$(I) ip link set dev lo up
	sudo ip netns exec test$(I) ip link add eth0 type veth peer name test$(I)
	sudo ip netns exec test$(I) ip link set dev test$(I) netns 1
	sudo ip netns exec test$(I) ip link set dev eth0 address 54:00:00:00:00:$(I)0
	sudo ip netns exec test$(I) ip addr add 10.42.0.$(I)0/24 dev eth0
	sudo ip netns exec test$(I) ip link set dev eth0 up
	sudo ip netns exec test$(I) ip neigh add 10.42.0.$(I) lladdr 54:00:00:00:00:0$(I) nud permanent dev eth0
	sudo ip link set dev test$(I) up
	sudo ip link set dev test$(I) address 54:00:00:00:00:0$(I)
	sudo ip addr add 10.42.0.$(I)/32 dev test$(I) noprefixroute
	sudo ip route add to 10.42.0.$(I)0/32 dev test$(I) src 10.42.0.$(I)
	sudo ethtool -K test$(I) tx off
	sudo ip netns exec test$(I) ethtool -K eth0 tx off

.PHONY: test-net
test-net: $(foreach container,$(CONTAINERS),test-container-$(container) )
\end{lstlisting}

\leavevmode\newline


This file alone is enough to configure a completely representative simulation of a possible infrastructure we might find on a ship. Eight network namespaces representing different physical components are created, and for each one a virtual Ethernet interface is also set up and paired with the loopback interface of the host machine that was previously brought up. As mentioned earlier, in keeping with namespace theory, each container is considered a separate device with its own MAC address, IP address, and network stack.
To be consistent with packet routing and to have a simulation as close to a real context as possible, transmit checksum offloading has also been disabled to avoid unexpected behavior due to the abstraction layers of network virtualization.

\begin{figure}[H]
	\centering
    \includegraphics[scale=0.4]{images/network_namespaces.png}
	\caption{Visualization of Linux Network Namespaces}
    \label{fig:network_namespaces}
\end{figure}

The only drawback of using network namespaces could be identified in the use abstraction layers of some kind that may give unrealistic results with slower or faster performance compared to the physical counterpart. But for the sake of research and study on the applicability of new networking strategies to legacy systems, our concerns for this part are mainly focused on the reproducibility of the network topology.

\section{The Rust Programming Language}
Upon delivery of packets to User Space, the developer assumes complete authority and accountability for the subsequent management and security of the data. This entails the obligation to ensure data is managed in a type and memory safe environment, with the preservation of information integrity being of paramount importance to the developer. Additionally, the software developed should be tailored to a performance-critical environment, where speed and efficiency are pivotal factors, as well as providing robust error and exception handling. The programming language selected for the switch development, Rust, is characterized by these features.

\subsection{Language features}

To elaborate on the aforementioned point, it should be noted that while all the features described are available in other programming languages, they are not all present simultaneously as in Rust. In addition, the following key aspects contribute to the selection of Rust as the optimal language for this implementation:

\begin{itemize}
    \item\textbf{Algebraic Type System}, which enables the use of product and sum types that can be mixed with a strong pattern matching paradigm. This combination enables a fast and easy way of destructuring and managing of complex data aggregations, which are frequently encountered in simulations characterized by a high level of structural detail
    \item\textbf{Zero-cost abstractions}, which were instrumental in eliminating runtime overhead on high-level constructs while preserving the performance of the equivalent low-level counterpart. This facilitated the seamless integration of functional programming paradigms, while maintaining complete awareness of the performance-critical nature of the software.
    \item\textbf{Unsafe block declarations} This feature facilitates raw memory access, reminiscent of other low-level languages such as C, while retaining the safety features inherent to Rust.
    In case of a memory error, the process of identifying the underlying cause is expedited since low-level hardware access is permitted within a controlled environment defined by the developer
\end{itemize}

It is worth mentioning that for the same reasons as the one previously stated, the US Defense Advanced Research Projects Agency (DARPA) initiated the TRACTOR project. Consequently, this implementation choice can also be regarded as a method of standardization with leading technologies that are becoming prevalent in the software development scenario.

\subsection{Project Layout}

In order to enhance the flexibility of our software and ensure scalability as an intrinsic feature of the switch, we have adopted a modular project layout. This approach utilizes one of Rust's sophisticated features for managing large-scale projects, known as cargo workspaces.
The adoption of this architectural paradigm has been shown to facilitate maintenance, construction, and testing of the project, while concurrently enabling the implementation of intelligent dependency management strategies.

The project is subdivided into a series of smaller, modular components, referred to as "crates." Each crate is assigned a particular responsibility, which can be versioned and published independently. This approach enhances reusability, management, and security.
The switch we developed is composed by six crates :

\begin{itemize}
    \item\textbf{ship\_component} : Crate responsible for each ship component abstraction, managing its networking capabilities and policy application based network filtering
    \item\textbf{ship} : Crate responsible ship abstraction, seen as a collection of ship components, managing the traffic coming from all of them and enabling basic switch features such as packet redirection
    \item\textbf{packet\_parser} : Crate responsible for network packet parsing and visualization
    \item\textbf{nmea} : Crate responsible for nmea messages recognition and parsing
    \item\textbf{policy\_handler} : Crate responsible for policy parsing and marshaling
    \item\textbf{simulation} : Main crate responsible for generation of the ship and its components starting from parsed policy files.
\end{itemize}

The strength of this architectural choice is retained in its modularity. The addition of functionalities related to data visualization, security, or statistical analysis can be achieved with minimal effort by incorporating an additional crate, which is essentially a directory, into the project. This flexibility is particularly advantageous in environments characterized by constantly evolving requirements that must align with existing architectures. In such contexts, the project's layout choice stands out as a superior solution.

\subsection{Components' Abstraction}

The integration of the language's distinctive characteristics and rich type system facilitated the simulation of the ship and its components. The life cycle and the interactions within the various devices were collapsed within just two crates constituting the project's fundamental structural elements.\\

\begin{lstlisting}
//ship.rs
pub struct Ship<'a> {
    components: Vec<ShipComponent<'a>>,
}

// ship_component.rs
pub struct ShipComponent<'a> {
    pub name: String,
    pub ifname: String,
    pub mac: String,
    pub ip: String,
    pub ifindex: libc::c_uint,
    pub bpf_manager: BPFRedirectManager,
    pub sock: XDPSocket<'a>,
    pub umem_allocator: UmemAllocator,
    pub poll_fd: libc::pollfd,
    pub sends: Vec<String>,
    pub receives: Vec<String>,
}
\end{lstlisting}

It is noteworthy that the ship itself and each component are implemented as a Struct product typ enabling the entire system simulation's creation to be as simple as initializing an array of variables and iterating over it, as it is possible to state looking at the program's main function\\

\begin{lstlisting}
fn main() {
    let policy = PolicyHandler::new(
        String::from("./policies/policy_0.toml")
        );
    let mut ship_components: Vec<ShipComponent> = Vec::new();
    let policy = policy.get_policy();
    policy.iter().for_each(|component| {
        ship_components.push(ShipComponent::new(
            component.name.clone(),
            component.iface.clone(),
            component.mac.clone(),
            component.ip.clone(),
            component.sends.clone(),
            component.receives.clone(),
        ));
    });

    let mut ship = Ship::new(ship_components);
    ship.monitor_network();
}
\end{lstlisting}

Ship components contain essential values required for networking in addition to static data, such as the MAC and IP addresses. There exist also variables that oversee the AF\_XDP socket bound to the component's NIC. This approach enables a high degree of flexibility by leveraging the \textbf{impl} pattern, which facilitates the definition of methods tailored to the component's specific functionality. A prime illustration of this methodology is evident in the manner in which each component administers the application of the network policy. \\

\begin{lstlisting}
impl ShipComponent<'_> {
    fn apply_policy(&self, message: String) -> (bool, bool, String) {
        let mut nmea = Nmea::new();
        let message_ok = nmea.parse(message.clone());

        match message_ok {
            Ok(()) => {
                nmea.show();
                let prefix = format!("${}{}", nmea.str_talker_id(), nmea.str_sentence_type());
                let is_allowed = self
                    .sends
                    .iter()
                    .any(|allowed_message| prefix == *allowed_message);
                (is_allowed, true, prefix)
            }

            Err(_) => (true, false, String::from("NONMEA")),
        }
    }
}
\end{lstlisting}

The policy is applied to the packets sent by the component with a level of granularity specific to itself.
In the present implementation, the UDP packet undergoes parsing and it is identified as a NMEA message if it conforms to the syntax rules of the protocol otherwise it is handled as a standard UDP message.
Subsequent to this, a basic control mechanism oversees the messages that can be dispatched by the component, as delineated in the policy. This mechanism determines whether or not the packet under scrutiny should be appended to the ship's traffic.

The analysis performed is relatively elementary, as it does not examine additional packet information beyond the aforementioned parameters. Utilizing this paradigm, it is feasible to implement more stringent rules, such as those that verify packet weight, payload characteristics, or unusual attributes to the packets' mean.
The capacity for data manipulation is boundless, enabling high-precision statistical analysis, the establishment of privilege systems among components, and more precise visualization of network status.

\subsection{Policy Implementation}
Another non-trivial feature to implement has been the policy handling.
The policy software market is saturated with infrastructure and application-dependent programs, the adoption of which in legacy systems might imply changes to currently adopted standards.
The objective was to engineer a policy system that is autonomous and environment-agnostic, thereby formalizing network communications without incurring computational overhead.
The most rational choice was to select the most basic configuration language, allowing the switch software to integrate it into its process.

TOML files, renowned for their simplicity, readability, and flexibility, emerged as the preferred choice for this purpose. To that end, the decision was made to leverage these advantageous features, resulting in the creation of a components' configuration file that is both immediately comprehensible and retains sufficient expressiveness and modularity.\\


\begin{lstlisting}
[policy]
c0 = { name = "girobussola", iface = "test1", mac = "54:00:00:00:00:10", ip = "10.42.0.10", sends = [
"$IIHDT",
], receives = [] }
c1 = { name = "ais", iface = "test2", mac = "54:00:00:00:00:20", ip = "10.42.0.20", sends = [
  "!AIVDM",
  "!AIVDO",
], receives = [] }
c2 = { name = "gps", iface = "test3", mac = "54:00:00:00:00:30", ip = "10.42.0.30", sends = [
  "$GPGGA",
  "$GPGLL",
  "$GPRMC",
], receives = [] }
c3 = { name = "ecoscandaglio", iface = "test4", mac = "54:00:00:00:00:40", ip = "10.42.0.40", sends = [
  "$IIDPT",
], receives = [] }
c4 = { name = "velocita", iface = "test5", mac = "54:00:00:00:00:50", ip = "10.42.0.50", sends = [
  "$IIVHW",
], receives = [] }
c5 = { name = "radar", iface = "test6", mac = "54:00:00:00:00:60", ip = "10.42.0.60", sends = [
  "$RATTM",
  "$RATLL",
  "$RAZDA",
], receives = [
  "$IIHDT",
  "!AIVDM",
  "$GPGGA",
  "$GPGLL",
  "$GPRMC",
  "$IIDPT",
  "$IIVHW",
] }
c6 = { name = "ecdis", iface = "test7", mac = "54:00:00:00:00:70", ip = "10.42.0.70", sends = [
], receives = [
  "$IIHDT",
  "!AIVDM",
  "!AIVDO",
  "$GPGGA",
  "$GPGLL",
  "$GPRMC",
  "$IIDPT",
  "$IIVHW",
  "$RATTM",
  "$RATLL",
  "$RAZDA",
] }

\end{lstlisting}

\leavevmode\newline

As demonstrated above, the TOML file is capable of defining not only policy rules through a list of permitted send and receive messages, but also the entire structure of the simulation.
The incorporation of a component into our OT system is a straightforward process, requiring only the addition of a line of configuration with basic networking information. The marshaling procedure is equally streamlined, a feat facilitated by the "toml" crate in Rust, which enabled the conversion of the TOML file into an efficient hash map data structure with minimal coding.\\

\leavevmode\newline

\begin{lstlisting}
#[derive(Debug, Deserialize)]
pub struct PolicyHandler {
    policy: HashMap<String, Component>,
}

#[derive(Debug, Deserialize, Clone)]
pub struct Component {
    pub name: String,
    pub iface: String,
    pub mac: String,
    pub ip: String,
    pub sends: Vec<String>,
    pub receives: Vec<String>,
}

impl PolicyHandler {
    pub fn new(policy_file_path: String) -> Self {
        let toml_content =
            fs::read_to_string(policy_file_path).expect("Failed to read config.toml");

        let policy_handler: PolicyHandler =
            toml::from_str(&toml_content).expect("Failed to parse config.toml");

        policy_handler
    }
}
\end{lstlisting}

\subsection{Network Simulation}

The components' networking capabilities, which leverage the AF\_XDP technology, were developed using the \textit{xdrippi} crate. This library provides low-level accessibility to the socket's main components through fairly simple APIs. 
The socket's initialization and setup is accomplished in a concise number of lines of code, as is the management of the ring buffers and UMEM. Furthermore it is necessary to highlight that the crate's implementation utilizes \textit{glibc} primitives for socket creation and management, which may potentially lead to unsafe memory management. However, as previously mentioned, the use of unsafe blocks ensures the security and reliability of this implementation choice.\\

\leavevmode\newline

\begin{lstlisting}
impl ShipComponent<'_> {
    pub fn new( name: String, ifname: String, mac: String,
        ip: String, sends: Vec<String>, receives: Vec<String>,
    ) -> Self {
        let ifindex = interface_name_to_index(ifname.as_str()).unwrap();

        let umem = Umem::new_2k(16384).unwrap();
        let umem = Arc::new(umem);
        let mut sock = XDPSocket::new(ifindex, 0, umem.clone(), 4096).unwrap();
        let mut bpf_manager = BPFRedirectManager::attach(ifindex);
        bpf_manager.add_redirect(0, sock.as_raw_fd());
        let umem_allocator = UmemAllocator::for_umem(umem.clone());

        while let Some(chunk_index) = umem_allocator.try_allocate() {
            if sock.fill_ring.can_produce() {
                sock.fill_ring
                    .produce_umem_offset(sock
                    .umem
                    .chunk_start_offset_for_index(chunk_index));
            } else {
                umem_allocator.release(chunk_index);
                break;
            }
        }

        let poll_fd = libc::pollfd {
            fd: sock.as_raw_fd(),
            events: libc::POLLIN,
            revents: 0,
        };

        ShipComponent {name,ifname,mac,ip,ifindex,bpf_manager,sock,
            umem_allocator,poll_fd,sends,receives,}
    }
}
\end{lstlisting}

\leavevmode\newline

The socket is created during the component's initialization, allocating UMEM memory frames for the Fill Buffer ring at startup. This ensures that the switch is ready to receive packets as soon as the device is added to the system.
Rust's strong pattern matching capabilities were leveraged to facilitate the parsing of network packets, thereby ensuring the efficiency of the process while retaining the benefits of low-level checking through zero-cost abstractions.
Constant monitoring of packet layers ensures precise identification of the data being processed, facilitating the creation of basic and filtered data flows with minimal effort.\\

\leavevmode\newline


\begin{lstlisting}
    pub fn parse_traffic(&self) -> Result<String, i32> {
        if let Some(eth_packet) = EthernetPacket::new(self.packet) {
            match eth_packet.get_ethertype() {
                EtherTypes::Ipv4 => {
                    if let Some(ipv4packet) = Ipv4Packet::new(eth_packet.payload()) {
                        return self.parse_protocol_ipv4(ipv4packet);
                    } else {
                        return Err(-1);
                    }
                }

                _ => return Err(-2),
            }
        }

        Err(-1)
    }
\end{lstlisting}






